---
lang: zh-CN
title: Vue3组件篇
description: vue描述
---

# 组合式 API

## setup

setup() 钩子是在组件中使用组合式 API 的入口，通常只在以下情况下使用：

- 需要在非单文件组件中使用组合式 API 时。
- 需要在基于选项式 API 的组件中集成基于组合式 API 的代码时。

其他情况下，都应优先使用 `<script setup>` 语法。

你可能见过很多写法：

:::: code-group
::: code-group-item 传统 setup

```ts{3}
<script>
//...
export default {
  setup() {
    // 业务代码写这里...
    return {
      // 需要给 template 用的数据、函数放这里 return 出去...
    }
  },//......
}
</script>
```

:::
::: code-group-item setup

```ts{2,3}
<script lang="ts">
import { defineComponent } from 'vue'
export default defineComponent({
  setup(props, context) {
    // 业务代码写这里...
    return {
      // 需要给 template 用的数据、函数放这里 return 出去...
    }
  },
})
</script>
```

:::
::: code-group-item setup 语法糖

```ts{1}
<script setup lang="ts">
// 业务代码写这里...
return {
      // 需要给 template 用的数据、函数放这里 return 出去...
    }
    //
    //
    //
    //......
    //
</script>
```

:::
::::

::: tip 提示
`defineComponent`可以用于 TypeScript 的类型推导，帮你简化掉很多编写过程中的类型定义。
不然使用 TS 时会需要写不少的类型定义接口。
:::

::: warning
使用 `setup` 的情况下，请牢记一点：不能再用 `this` 来获取 `Vue` 实例，也就是无法通过 `this.xxx 、 this.fn()` 这样来获取实例上的数据，或者执行实例上的方法。
全新的 Vue 3 组件编写，请继续往下看，会一步一步做说明。
:::

|  参数   |  类型  |          含义          | 是否必传 |
| :-----: | :----: | :--------------------: | :------: |
|  props  | object | 由父组件传递下来的数据 |    否    |
| context | object |    组件的执行上下文    |    否    |

> props

它是响应式的（只要你不解构它，或者使用 `toRef / toRefs`(后续讲解) 进行响应式数据转换），当传入新的 prop 时，它将被更新。

> context

context 只是一个普通的对象，它暴露三个组件的 property：

| 属性  |     类型     |               作用               |
| :---: | :----------: | :------------------------------: |
| attrs | 非响应式对象 | props 未定义的属性都将变成 attrs |
| slots | 非响应式对象 |               插槽               |
| emit  |     方法     |             触发事件             |

因为 context 只是一个普通对象，所以你可以直接使用 ES6 解构。
平时使用可以通过直接传入 { emit } ，即可用 emit('xxx') 来代替使用 context.emit('xxx')，另外两个功能也是如此。
但是 attrs 和 slots 请保持 attrs.xxx、slots.xxx 来使用他们数据，不要解构这两个属性，因为他们虽然不是响应式对象，但会随组件本身的更新而更新。

## ref

ref 是最常用的一个响应式 API，它可以用来定义所有类型的数据，包括 Node 节点。

是否学过 vue2，在 2.x 常用的 this.$refs.xxx 来取代 document.querySelector('.xxx')获取 Node 节点的方式，也是用这个 API 来取代。

在开始使用 API 之前，要先了解一下在 TypeScript 中，ref 需要如何进行类型声明。

```js
//平时我们定义变量可以这进行类型声明
// 单类型
const msg: string = "Hello World!";
// 多类型
const phoneNumber: number | string = 13800138000;

//但是在使用 ref 时，不能这样子声明，会报错，正确的声明方式应该是使用 <> 来包裹类型定义，紧跟在 ref API 之后：
// 单类型
const msg = ref < string > "Hello World!";
// 多类型
const phoneNumber = (ref < number) | (string > 13800138000);
```

```js
const msg = ref < string > "Hello World!";
//等价于
const msg = ref < string > { value: "Hello World!" };
console.log(msg.value);
//你也可以这样使用
const msg = ref({ name: "Hello World!" });
//取值需要
console.log(msg.value.name);
```

#### ref 可以定义多种数据类型

:::: code-group
::: code-group-item 基本类型

```ts
//对于字符串，布尔值等基本类型的定义方式
//字符串
const msg = ref<string>("www");

//数值
const msg_2 = ref<number>(1);

//布尔值
const msg_3 = ref<boolean>(true);
```

:::
::: code-group-item 对象类型

```ts
// 对于对象、数组等引用类型也适用，比如要定义一个对象：
//声明对象格式
interface Member {
  id: number;
  name: string;
}
//定义成员对象
const userinfo =
  ref <
  Member >
  {
    id: 1,
    name: "Tom",
  };
```

:::
::: code-group-item 数组类型

```ts
//普通数组
const uids = ref<number[]>([1,2,3,4,5,6,7]);
//字符串数组
const names = =ref<string[]>(['Tom','petter','chenzi']);

//定义对象数组
interface Member{
    id:number,
    name:string
};

const memberList = ref<Member[]>([
    {
        id:1,
        name:"001"
    },
    {
        id:2,
        name:"002"
    }
])
```

:::
::: code-group-item DOM 元素与子组件

```vue
<template>
  <!-- 挂载DOM元素 -->
  <p ref="msg">留意该节点，有一个ref属性</p>
  <!-- 挂载DOM元素 -->
  <!-- 挂载子组件 -->
  <Child ref="child" />
  <!-- 挂载子组件 -->
</template>
<script setup lang="ts">
components: {
   Child
 },
    // 定义挂载节点，声明的类型详见下方附表
   const msg = ref<HTMLElement | null>(null);
   const child = ref<typeof Child | null>(null);
    // 必须return出去才可以给到template使用
    return {
      msg,
      child
    }
</script>
```

:::
::::

::: tip
被 `ref` 包裹的变量会全部变成对象，不管你定义的是什么类型的值，都会转化为一个 `ref` 对象，其中 `ref` 对象具有指向内部值的单个 `property.value`。
:::

:::: code-group
::: code-group-item 普通取值

```ts{3,7}
// 读取一个字符串
const msg: string = 'Hello World!';
console.log('msg的值', msg);

// 读取一个数组
const uids: number[] = [ 1, 2, 3 ];
console.log('第二个uid', uids[1]);
```

:::
::: code-group-item ref 取值

```ts{3,7}
// 读取一个字符串
const msg = ref<string>('Hello World!');
console.log('msg的值', msg.value);

// 读取一个数组
const uids = ref<number[]>([ 1, 2, 3 ]);
console.log('第二个uid', uids.value[1]);
```

:::
::::

> ref 全家桶

|     函数     |                                               描述                                               |
| :----------: | :----------------------------------------------------------------------------------------------: |
|    `ref`     |                                       声明是一个响应式对象                                       |
|   `isRef`    |                               判断是否为响应式对象，源码出现比较多                               |
| `shallowRef` |         浅层的响应，只改变`.value`,不能用来监听深层对象，如：Object，切记不要和`ref`混用         |
| `triggerRef` |     响应式更新，这是底层更新数据的方法，强制更新 ref，这就是`ref`,`shallowRef`不能混用的原因     |
| `customRef`  | 自定义创建`ref`响应对象的`function`，可以在触发更新时添加一些自定义操作，更新也是调用 triggerRef |


> 代码说明


::: details 点击进一步学习源码
```ts{5,60}
//只截取一部分代码说明。可以去vue仓库自己查看
/**
 * ref函数重载
 */
export function ref<T extends object>(
  value: T
): [T] extends [Ref] ? T : Ref<UnwrapRef<T>>
export function ref<T>(value: T): Ref<UnwrapRef<T>>
export function ref<T = any>(): Ref<T | undefined>
export function ref(value?: unknown) {
  return createRef(value, false) //这个就是我们的响应对象
}

function createRef(rawValue: unknown, shallow: boolean) {
    //判断value是不是ref对象，是的话不用处理，直接返回即可
  if (isRef(rawValue)) {
    return rawValue
  }
  //如果不是,new一个ref对象，参数是value,和状态，注意上面直接是false
  return new RefImpl(rawValue, shallow)
}

class RefImpl<T> {
  private _value: T
  private _rawValue: T

  public dep?: Dep = undefined
  public readonly __v_isRef = true

  //接收value和Shallow，全程我们只响应value
  constructor(value: T, public readonly __v_isShallow: boolean) {
    this._rawValue = __v_isShallow ? value : toRaw(value)
    /**这里Shallow为true就直接返回value，为false调用了toReactive(value)
     * toReactive(value)在后续中说明；这里只需要知道：
     * 如果value是Object，他会去调reactive(value)
     * 如果value不是Object，他直接返回value
     */
    this._value = __v_isShallow ? value : toReactive(value)
  }

  get value() {
    //依赖收集
    trackRefValue(this)
    return this._value
  }

  set value(newVal) {
    const useDirectValue =
      this.__v_isShallow || isShallow(newVal) || isReadonly(newVal)
    newVal = useDirectValue ? newVal : toRaw(newVal)
    if (hasChanged(newVal, this._rawValue)) {
      this._rawValue = newVal
      this._value = useDirectValue ? newVal : toReactive(newVal)
      //触发响应更新数据
      triggerRefValue(this, newVal)
    }
  }
}

//可以看到他和ref几乎是一样的，不同在于createRef(value,${true}),传值变为了true
export function shallowRef<T extends object>(
  value: T
): T extends Ref ? T : ShallowRef<T>
export function shallowRef<T>(value: T): ShallowRef<T>
export function shallowRef<T = any>(): ShallowRef<T | undefined>
export function shallowRef(value?: unknown) {
  return createRef(value, true) //true，他永远只会返回第一层value
}


//可以看出triggerRef底层都是调用了triggerRefValue
export function triggerRef(ref: Ref) {
  triggerRefValue(ref, __DEV__ ? ref.value : void 0)
}

//调用triggerEffects更新数据
export function triggerRefValue(ref: RefBase<any>, newVal?: any) {
  ref = toRaw(ref)
  if (ref.dep) {
    if (__DEV__) {
      triggerEffects(ref.dep, {
        target: ref,
        type: TriggerOpTypes.SET,
        key: 'value',
        newValue: newVal
      })
    } else {
      triggerEffects(ref.dep)
    }
  }
}
```
:::

## reactive
